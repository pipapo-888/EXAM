# FCLOSE(3) — Linux Programmer's Manual

## 名前
fclose — ストリームを閉じる

## 書式
```c
#include <stdio.h>

int fclose(FILE *stream);
```

## 説明
`fclose()` は、指定されたストリーム `stream` を閉じ、関連するすべてのバッファをフラッシュし、
ファイルディスクリプターを解放する。  
この操作により、`fopen(3)`、`freopen(3)`、`fdopen(3)` などでオープンされたストリームは
利用できなくなる。

ストリームが出力用または更新用モードで開かれている場合、
`fclose()` は内部バッファに残っているデータを基礎となるファイルまたはデバイスに書き出す。  
この書き込み中にエラーが発生した場合、`fclose()` は `EOF` を返す。

ストリームが入力専用である場合、`fclose()` は単に関連リソースを解放する。

`fclose()` の呼び出し後に同じ `FILE *` ポインタを使用することは未定義動作である。

## 返り値
成功時：0  
失敗時：`EOF`（`-1`）を返し、`errno` にエラー番号が設定される。

## エラー
`fclose()` 自体は多くの場合ファイルシステムレベルのエラーを伝搬する。
主なエラー例：  
- `EBADF` — 無効なファイルディスクリプター。  
- `EIO` — 入出力エラー。  
- `ENOMEM` — 内部バッファ解放失敗。

## 属性
| インタフェース | 属性 | 値 |
|---|---|---|
| `fclose()` | スレッド安全性 | MT-Safe |

## 準拠
C89, C99, POSIX.1-2001, POSIX.1-2008 に準拠。

## 注記（NOTES）
- `fclose()` が `EOF` を返しても、基礎となるファイルディスクリプターはすでに閉じられている可能性がある。
  そのため、エラー後のリカバリを行う場合には注意が必要である。
- 出力ストリームのバッファフラッシュ時にエラーが発生しても、`errno` が更新されない実装が存在する。
  安全なエラーチェックのためには、書き込み後に `ferror(3)` を呼び出すのが望ましい。
- `fclose()` は内部的に `fflush(3)` を呼び出してから `close(2)` を実行するため、
  `fflush()` の失敗があっても FD はクローズされる。

## 例
```c
#include <stdio.h>

int main(void) {
    FILE *fp = fopen("test.txt", "w");
    if (!fp) return 1;

    fputs("テスト文字列\n", fp);
    if (fclose(fp) == EOF) {
        perror("fclose");
        return 1;
    }
    return 0;
}
```

## 関連項目
`fopen(3)`, `freopen(3)`, `fflush(3)`, `ferror(3)`, `close(2)`

## コロフォン（COLOPHON）
このページは Linux man-pages プロジェクトの一部である。プロジェクトの説明、バグ報告、および最新版の入手方法については：  
<https://www.kernel.org/doc/man-pages/>

---

## 解説（実務的補足）
- 出力ストリームを閉じる前に明示的に `fflush()` を呼び出すと、エラー発生箇所を明確に切り分けやすくなる。  
- 多重クローズ（同じ `FILE*` の二度目の `fclose()`）は未定義動作であり、クラッシュを引き起こす可能性がある。  
- `fclose()` はファイルディスクリプターを返さないため、低レベル API (`close(2)`) との併用には注意。  
- エラー時にファイルが正しくクローズされたかを検証したい場合は、`fsync(2)` を併用すると確実。
