# STRNCMP(3) — Linux Programmer's Manual

## 名前
strncmp — 文字列を一定長まで比較する

## 書式
```c
#include <string.h>

int strncmp(const char *s1, const char *s2, size_t n);
```

## 説明
`strncmp()` は、文字列 `s1` と `s2` の最初の `n` バイト（または終端ヌル文字 `\0` に達するまで）を比較する。  
両文字列の各バイトを `unsigned char` として比較し、次の条件に従って結果を返す：

- `s1` が `s2` より小さい場合：負の値  
- `s1` が `s2` と等しい場合：0  
- `s1` が `s2` より大きい場合：正の値  

`strncmp()` は、`strcmp(3)` と異なり、`n` 文字を超えて比較しない点が異なる。  
比較の対象は `n` バイト以内またはいずれかの文字列が終端に達するまでである。

この関数は主に、固定長バッファ上で安全に文字列を比較するために利用される。

## 返り値
`s1` の最初に異なる文字が現れた位置で、
`s1[i] - s2[i]`（`unsigned char` として評価）の値を返す。
一致している場合は 0。

## エラー
`strncmp()` 自体は `errno` を設定しない。  
ただし、無効なポインタを渡した場合の動作は未定義である。

## 属性
| インタフェース | 属性 | 値 |
|---|---|---|
| `strncmp()` | スレッド安全性 | MT-Safe |

## 準拠
C89, C99, POSIX.1-2001, POSIX.1-2008 に準拠。

## 注記（NOTES）
- 大文字／小文字を区別しない比較には `strncasecmp(3)` を使用する。  
- `strncmp()` は `memcmp(3)` に類似しているが、ヌル終端を考慮する点で異なる。  
- 比較の途中でヌル終端に達しても、残りの部分は比較されない。  
- `n` の値が非常に大きい場合（バッファ長より大）、未定義動作（領域外アクセス）を起こす危険がある。

## 例
```c
#include <stdio.h>
#include <string.h>

int main(void) {
    const char *a = "apple";
    const char *b = "application";

    if (strncmp(a, b, 3) == 0)
        puts("最初の3文字は一致します。");
    else
        puts("異なります。");

    return 0;
}
```

## 関連項目
`strcmp(3)`, `strncasecmp(3)`, `memcmp(3)`, `strncmp(3)`

## コロフォン（COLOPHON）
このページは Linux man-pages プロジェクトの一部である。プロジェクトの説明、バグ報告、および最新版の入手方法については：  
<https://www.kernel.org/doc/man-pages/>

---

## 解説（実務的補足）
- **安全な文字列比較**：`strncmp()` は上限 `n` を指定できるため、バッファオーバーランを防げる。  
- **典型的用途**：ファイル拡張子判定（例：`strncmp(name + len - 4, ".txt", 4)`）。  
- **注意点**：`n` の上限を誤ると比較漏れや意図しない一致が起こる。  
- **速度**：最悪でも `n` 回の比較で終了するため、線形 O(n) 時間。  
- **実装**：glibc ではアセンブリ最適化が施されており、大きな配列比較でも高速。