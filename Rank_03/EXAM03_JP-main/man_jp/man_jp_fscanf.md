SCANF(3) — Linux Programmer's Manual
名前
scanf, fscanf, sscanf, vscanf, vfscanf, vsscanf — 書式化入力関数

書式
c
￼コードをコピーする
#include <stdio.h>

int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);

#include <stdarg.h>

int vscanf(const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
説明
これらの関数は、フォーマット文字列 format に従って、
入力ストリームや文字列からデータを読み込み、指定された引数に代入する。

関数	入力元
scanf()	標準入力 (stdin)
fscanf()	指定されたファイルストリーム stream
sscanf()	文字列 str
￼
同様に、vscanf(), vfscanf(), vsscanf() は可変引数リスト va_list を用いるバリアントである。

これらの関数は printf(3) ファミリと同様の書式構文を使用するが、
データを読み取って変数に格納する点が異なる。
format 文字列は通常の文字列と、入力の解析方法を指定する「変換指定子（conversion specification）」を含む。

書式文字列
フォーマット文字列 format は、
通常の文字（空白を含まない）および % で始まる変換指定子から構成される。

入力が通常の文字に一致しなければ、スキャンは停止し、以降の入力は未処理のまま残る。
空白文字（スペース、タブ、改行）は、入力中の任意の空白シーケンスと一致する。

変換指定子は次の形式を取る：

css
￼コードをコピーする
%[*][width][length]specifier
各部分の意味は以下のとおりである：

*
このオプションが指定されると、入力値は読み取られるが、
対応する引数には代入されない。

width
最大読み取り文字数を指定する整数。
指定がない場合、読み取りは入力形式やスペース等で自動的に停止する。

length
データの型修飾を指定する（例：h, l, ll, L, z, t など）。

specifier
入力データの解釈形式を指定する文字。主な指定子は次の通り：

指定子	意味
d	10進整数として読み取る
i	整数（基数自動判別：0x → 16進、0 → 8進）
o	8進整数
u	符号なし10進整数
x, X	16進整数
f, e, E, g, G, a, A	浮動小数点数
c	文字1つ（空白も含める）
s	空白以外の文字列
p	ポインタ値（実装依存）
%	リテラル % 文字
[...]	文字集合の一致（%[abc] のように指定）

変換（Conversions）

変換指定子は、入力の内容を解析して対応する引数に格納する。
各変換指定子は、対応する引数として ポインタ を要求する。
このポインタが示す変数に、変換結果が代入される。

入力の解析は format 文字列に従い、入力の途中で不一致やEOF（入力の終端）に到達した場合、
それ以降の入力は処理されず残る。

scanf() ファミリは、整数、浮動小数点、文字列、ポインタなどの型に対応している。
読み取られるデータは、入力テキストの形式に基づき自動的に解釈される。

整数変換

%d, %i, %o, %u, %x, %X
これらは整数値を読み取る。%i は入力の先頭に 0x（16進）または 0（8進）がある場合に自動判別する。

浮動小数点変換

%f, %e, %E, %g, %G, %a, %A
これらは浮動小数点数を読み取る。
指数表記（1.23e+10 など）も解釈される。

文字列変換

%s は空白文字（スペース・改行・タブ）に遭遇するまでの文字列を読み取る。
終端の '\0' は自動的に追加される。
読み取り上限を指定しない場合、入力サイズによりバッファオーバーフローが発生する危険がある。

単一文字変換

%c は1文字をそのまま読み取る（空白も含める）。
%lc はワイド文字を読み取る。

文字集合変換

%[文字集合] 構文を使用すると、特定の文字集合に一致する文字列を読み取る。
例：%[a-z] は小文字の英字のみを読み取る。
先頭が ^ の場合（例：%[^0-9]）、指定された集合を除外する。

ポインタ変換

%p は入力をポインタ値として解釈する（実装依存の形式）。
出力は void * 型のポインタに格納される。

特殊変換

%% はリテラルの % を読み取る。

戻り値（RETURN VALUE）

これらの関数は、正常に代入された項目数（変換された引数の個数）を返す。
この値はゼロ以上の整数である。
不一致や入力エラーが発生した場合、入力処理は停止する。

戻り値の規則：

戻り値	意味
正の値	正常に読み取られた項目数
0	入力が期待された形式に一致しなかった
EOF	入力ストリームの終端、またはエラーにより読み取りが不能

エラー（ERRORS）

scanf() ファミリの関数は、ファイルストリーム操作中にエラーが発生した場合、
入力処理を停止し、未処理の入力を残す。

主なエラー条件：

エラー	意味
EOF	入力の終端に達した
EILSEQ	無効なマルチバイトシーケンス（ロケール依存）
ENOMEM	メモリ不足（内部バッファ確保失敗）
その他	ストリームエラー（ferror(stream) が真になる）

errno が設定される場合もあるが、POSIX.1 では特定の値は規定されていない。

属性（ATTRIBUTES）
インタフェース	属性	値
scanf(), fscanf(), sscanf()	スレッド安全性	MT-Safe locale
準拠（CONFORMING TO）

C89, C99, POSIX.1-2001, POSIX.1-2008。

注意（NOTES）

%s 変換を使用する際には、読み取り文字数に上限を指定しないと、
入力サイズが不明な場合にバッファオーバーフローが発生する可能性がある。
例：char buf[10]; scanf("%9s", buf);

scanf() ファミリは、読み取り後に末尾の改行や空白を消費する仕様があるため、
次の入力に影響することがある。

ferror(3) と feof(3) を用いて、ストリームの状態を明示的に確認できる。

ロケール依存の数値フォーマット（小数点記号など）に注意すること。

例（EXAMPLES）
#include <stdio.h>

int main(void)
{
    int i;
    float x;
    char str[20];

    printf("Input: ");
    if (scanf("%d %f %19s", &i, &x, str) == 3)
        printf("Read values: i=%d, x=%f, str=%s\n", i, x, str);
    else
        printf("Input error or format mismatch\n");
    return 0;
}


実行例：

Input: 42 3.14 hello
Read values: i=42, x=3.140000, str=hello

関連項目（SEE ALSO）

printf(3), getc(3), getchar(3), fgets(3), strtol(3), strtod(3), ferror(3)

コロフォン（COLOPHON）

このページは Linux man-pages プロジェクトの一部である。
プロジェクトの説明、バグ報告、および最新版の入手方法については：
https://www.kernel.org/doc/man-pages/

解説（実務的補足）

安全な入力
scanf() は境界を超える入力に対して脆弱になりやすい。
必ずフィールド幅（例：%9s）を指定するか、fgets()＋sscanf() の組み合わせを使用する。

戻り値の確認
入力形式が正しいかを判定するためには、必ず戻り値を確認する。
scanf() の戻り値が期待する項目数に一致しない場合は、入力エラーまたは形式不一致である。

ロケール影響
数値入力時の小数点文字（. or ,）は LC_NUMERIC に依存する。
国際化環境ではこの点に留意が必要。

ストリームとファイル
fscanf() は任意のファイルストリームを対象とできる。
標準入力でない場合でも同じフォーマット指定が利用可能。