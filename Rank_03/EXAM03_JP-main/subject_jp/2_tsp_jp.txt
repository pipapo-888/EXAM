TSP(1)                                 User Commands                                 TSP(1)

NAME
       tsp - 巡回セールスマン問題 (Traveling Salesman Problem) を解くプログラム

SYNOPSIS
       ./tsp n

DESCRIPTION
       tsp プログラムは、巡回セールスマン問題 (TSP: Traveling Salesman Problem) を解くための
       教育目的のアルゴリズム課題である。

       巡回セールスマン問題とは、都市群とそれぞれの間の移動コスト（距離）が与えられたとき、
       すべての都市を一度ずつ訪問して出発点に戻る最短経路を求める最適化問題である。

       本プログラムでは、都市数 n が入力として与えられ、距離行列が固定または標準入力で与えられる。
       プログラムは全探索（brute-force）またはバックトラッキングにより最短経路長を求める。

       出力は、最小コスト（距離）を整数で表示する。

       この問題は NP 完全であり、入力規模が増えると計算量が指数的に増加するため、
       実装では探索の最適化（枝刈り）を適宜導入することが望ましい。

       距離行列の例：

           0 10 15 20
           10 0 35 25
           15 35 0 30
           20 25 30 0

       上記は 4 都市間の距離を表している。

       例として、経路 1→2→4→3→1 の総距離は 10 + 25 + 30 + 15 = 80 である。
       このうち最短経路を探索する。

RETURN VALUE
       成功時に 0 を返す。
       不正な引数、メモリエラー、入力ファイルエラーの場合は 1 を返す。

ERRORS
       •   引数が指定されていない、または整数でない。
       •   n が 2 未満である。
       •   距離行列が不完全または不正。
       •   メモリ確保に失敗した。

EXAMPLES
       $> ./tsp 4
       最短距離: 80

       入力行列が上記の例であれば、最小コスト経路の総距離 80 を出力する。

NOTES
       巡回セールスマン問題は古典的な組合せ最適化問題であり、完全探索の計算量は O(n!) となる。
       n が大きい場合には、以下のような改善手法を用いることが多い。

       1. **バックトラッキング + 枝刈り**
          - 部分経路のコストが既知の最良値を超えた時点で探索を打ち切る。

       2. **動的計画法 (Held-Karp アルゴリズム)**
          - ビットマスクで訪問状態を管理し、部分問題を動的に再利用する。
          - 計算量は O(n² × 2ⁿ)。

       3. **近似アルゴリズム**
          - 貪欲法や最短挿入法などで近似解を高速に求める。

       4. **メタヒューリスティクス**
          - 遺伝的アルゴリズム、焼きなまし法などを用いることで、大規模問題を現実的時間で解く。

SEE ALSO
       permutations(3), backtracking(3), dynamic_programming(3), malloc(3), printf(3)

───────────────────────────────────────────────
解説
───────────────────────────────────────────────
1. **課題の目的**
   - 組合せ最適化問題における探索アルゴリズムの理解。
   - 全探索（brute-force）・バックトラッキング・動的計画法の比較を通して、
     時間計算量と探索効率の関係を体験的に学ぶ。

2. **アルゴリズム概要**
   - **完全探索法：**
     - 都市のすべての順列（n! 通り）を生成し、それぞれの総距離を計算する。
     - 最短距離を更新し続けることで最終解を得る。
     - 実装は `permutations` 課題と構造的に類似している。

   - **バックトラッキング法：**
     - 再帰的に都市を追加し、部分経路のコストが既知の最短値を超える場合は探索を打ち切る。
     - 効率は O(k × n!) より大幅に改善される。

   - **動的計画法（Held-Karp）：**
     - 部分集合 S における最短経路長 dp[S][i] を記録し、再利用することで計算量を削減する。
     - 状態数は 2ⁿ × n。

3. **技術的実装要点**
   - 入力距離行列は 2 次元配列で管理する。
   - 訪問状態を示す配列（またはビットマスク）を利用する。
   - 再帰関数で「現在地」「訪問済み集合」「累積コスト」を引数に持つ。
   - ベースケースでは、全都市訪問後に出発点への戻りコストを加算する。

4. **性能・制約**
   - 時間計算量：O(n!)
   - 空間計算量：O(n)
   - n ≤ 10 程度であれば完全探索が現実的、それ以上では DP または近似法を検討する。

5. **教育的意図**
   - TSP は「探索空間の爆発」「枝刈りの有効性」「最適化の限界」を実際に体験できる課題である。
   - `n_queens`・`permutations`・`powerset` などの再帰課題と並び、
     **探索問題の最終段階（最適化問題）** に位置づけられる。
   - 42 カリキュラムでは、再帰構造の一般化・効率化・評価基準の導入を学ぶ導入課題として設計されている。

6. **発展的考察**
   - 都市数が 20 を超えると、全探索法では計算不可能に近くなる。
   - メモ化再帰による DP 化（Held-Karp 法）を実装することで劇的に高速化できる。
   - 実際の応用例には物流・配送計画・ロボット経路計画などがある。

この課題は、組合せ爆発を伴う最適化問題に対して
「探索＋制約＋最適化」の三要素を総合的に理解させるための応用的演習である。
