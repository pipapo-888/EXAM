PERMUTATIONS(1)                         User Commands                         PERMUTATIONS(1)

NAME
       permutations - 与えられた要素のすべての順列を生成するプログラム

SYNOPSIS
       ./permutations n

DESCRIPTION
       permutations プログラムは、1 から n までの整数を並べ替えたすべての順列を生成し、
       それらを標準出力に出力するユーティリティである。

       引数 n は、生成する順列の要素数を指定する正の整数である。

       順列の定義：
           n 個の異なる要素を、順序を考慮して並べ替えた集合。
           その総数は n!（n の階乗）である。

       本プログラムは、再帰的または逐次的なアルゴリズムにより、
       与えられた要素のすべての組み合わせを一意に生成し、出力する。

       出力形式は、各順列を 1 行として表示し、各要素は空白で区切られる。

       例：n = 3 の場合、出力は次の通り。

           1 2 3
           1 3 2
           2 1 3
           2 3 1
           3 1 2
           3 2 1

       アルゴリズムの一般的な構成は以下の通りである。

       •  現在の位置に配置する要素を 1 つずつ選び、残りの要素で再帰呼び出しを行う。
       •  すべての要素が配置された段階で、1 つの順列を完成とみなし出力する。
       •  バックトラックにより、すべての組み合わせを網羅する。

       本プログラムは、順列生成における再帰構造の理解を目的とする教育的課題である。

RETURN VALUE
       成功時に 0 を返す。
       引数が不正な場合、またはメモリ確保に失敗した場合は 1 を返す。

ERRORS
       •   引数が指定されていない場合
       •   引数が整数でない場合
       •   引数が 1 未満の場合
       •   メモリ確保に失敗した場合

EXAMPLES
       $> ./permutations 3
       1 2 3
       1 3 2
       2 1 3
       2 3 1
       3 1 2
       3 2 1

       上記の例は、{1,2,3} の全順列を生成して出力する。

NOTES
       順列の生成には以下の 2 通りの代表的手法がある。

       1. 再帰的スワップ法
          - 配列の i 番目から順に要素を固定し、残りの部分で再帰的にスワップを行う。
          - 各再帰呼び出しで順列の 1 要素を確定する。

       2. Heap’s Algorithm
          - 再帰ではなくループ構造で全順列を生成する効率的なアルゴリズム。
          - 計算量は O(n!) であり、生成順序に重複がない。

SEE ALSO
       recursion(3), backtracking(3), malloc(3), printf(3), swap(3)

───────────────────────────────────────────────
解説
───────────────────────────────────────────────
1. **課題の目的**
   - 順列生成を通して、再帰構造と状態遷移の理解を深める。
   - 要素のスワップ操作とバックトラックの概念を明確に把握する。

2. **アルゴリズム概要**
   - 配列 a[0..n-1] に対し、位置 k を固定して以降を順列化する。
   - k が n-1 に達した場合、その時点の配列が 1 つの順列として出力される。
   - 各ステップで i を k から n-1 まで走査し、a[k] と a[i] をスワップ。
     再帰呼び出し後、元に戻す（バックトラック）。

   疑似コード例：
       void permute(int *arr, int k, int n)
       {
           if (k == n)
               print(arr);
           else
               for (int i = k; i < n; i++) {
                   swap(&arr[k], &arr[i]);
                   permute(arr, k + 1, n);
                   swap(&arr[k], &arr[i]);
               }
       }

3. **性能特性**
   - 時間計算量：O(n!)（全順列の数と一致）
   - 空間計算量：O(n)（再帰スタックの深さ）

4. **注意点**
   - メモリの動的確保を行う場合、free(3) による適切な解放が必要。
   - 出力形式の整形（空白区切り、改行処理）を正確に行う。
   - 標準出力の flush を明示する場合、`fflush(stdout)` を使用可能。

5. **教育的意図**
   - `permutations` 課題は、N_QUEENS や POWERSET など他の組み合わせ系課題の基礎である。
   - 状態探索の網羅性と再帰設計の習得を目的としている。
   - 再帰的関数の呼び出し構造や、関数呼び出しごとの変数スコープの挙動を観察できる。

この課題は、C 言語による再帰と状態管理を実践的に学ぶ基礎演習であり、
アルゴリズム設計・デバッグ力を強化する良い訓練である。
